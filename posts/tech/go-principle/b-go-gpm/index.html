<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go原理：调度器和GPM模型 | 往往不的攻略笔记</title><meta name=keywords content="Go,principle,调度"><meta name=description content="Go 的调度器原理学习记录，深入理解 GPM 模型，了解 Go 并发能力的来源。"><meta name=author content="
作者:&nbsp;往往不"><link rel=canonical href=https://www.wangwangbu.com/posts/tech/go-principle/b-go-gpm/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.wangwangbu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.wangwangbu.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.wangwangbu.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.wangwangbu.com/apple-touch-icon.png><link rel=mask-icon href=https://www.wangwangbu.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go原理：调度器和GPM模型"><meta property="og:description" content="Go 的调度器原理学习记录，深入理解 GPM 模型，了解 Go 并发能力的来源。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.wangwangbu.com/posts/tech/go-principle/b-go-gpm/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go原理：调度器和GPM模型"><meta name=twitter:description content="Go 的调度器原理学习记录，深入理解 GPM 模型，了解 Go 并发能力的来源。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚升级","item":"https://www.wangwangbu.com/posts/"},{"@type":"ListItem","position":2,"name":"技巧 ➕","item":"https://www.wangwangbu.com/posts/tech/"},{"@type":"ListItem","position":3,"name":"Go原理：调度器和GPM模型","item":"https://www.wangwangbu.com/posts/tech/go-principle/b-go-gpm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go原理：调度器和GPM模型","name":"Go原理：调度器和GPM模型","description":"Go 的调度器原理学习记录，深入理解 GPM 模型，了解 Go 并发能力的来源。","keywords":["Go","principle","调度"],"articleBody":"前言 我们都知道 Goroutine 是 Go 的语言特色，也可以称之为协程。协程是运行在线程上的，而不同的协程和线程之间的调度则受“调度器”这一机制控制。\n那么什么是调度器，它又是如何实现的呢？\n调度器 我们追根溯源，了解一下调度器是如何出现的。\n早期单进程操作系统根本不需要调度器，进程遵循顺序执行，每个进程都要等上一个进程执行完才能执行。可是这样一个进程阻塞，后面的进程也无法执行。 后来有了多进程/多线程操作系统，一个进程阻塞可以让 CPU 执行别的进程，这就有了调度需求（Linux 中进程和线程等价控制）。但是进程间切换需要占用 CPU 资源，并且线程也占用较大内存（4MB）。 因为对于 CPU 来说只管理线程的调度即“内核态”，对每个线程绑定的用户空间或是说具体运行代码是什么样的并不关心，因此可以将这部分用户空间划分出来用户自己控制，就叫做协程，而“内核态”的线程也就是受 CPU 控制的那部分还叫做线程。 如果一个协程绑定一个线程，那协程的创建、删除和切换都是由 CPU 完成，代价太高；如果多个协程绑定一个线程，一旦某个协程阻塞，线程也会阻塞，其他协程也运行不了了。\n因此使用多个协程绑定多个线程的模式，那协程的分配和线程的选择就需要中间有一个调度器的存在。\nGMP 模型 调度器是一个组件，也是一种机制的实现。Go 语言的调度器是一个 GMP 模型。所谓 GMP 模型就是协程 G (Goroutine)，线程 M (thread) 以及处理器 P (Processor)。\n你可能感到很疑惑，不是说协程和线程的事吗，怎么又冒出来个处理器。其实早期 Go 的调度器是没有处理器的，只有多个协程和一个全局 Goroutine 队列。但是这样就涉及到 Goroutine 的竞争，效率并不高。所以后来引入了处理器 P，以及它带着的本地 Goroutine 队列。\n因此在 GMP 模型中，有一个装载 G 的全局队列，每个 P 还有一个装载 G 的本地队列。\n我们打个比方，协程 G 就像是游戏里的任务，而线程 M 就是想做任务的玩家，而处理器 P 是各地任务大厅的 NPC。\nM 需要做任务就要先找到一个 P 绑定，从它的本地队列接任务 G 做，做完（或是做一定时间）之后再接。\n听上去很简单，也还有一些细节需要补充：\nP 是程序是程序启动时创建的，由环境变量控制数量； M 绑定的 P 中如果没有 G 了，会从全局队列中找 G，没有的话会从其他 P 的本地队列偷一半 G 过来； 如果本地队列满了，再创建或执行完回来的 G 会放到全局队列； 如果 G 进入系统调用，M 会将它的 P 分给一个休眠队列的 M 或是新增一个 M； G 的系统调用完毕，则会加入一个空闲的 P 中，没有则放入全局队列，M 则进入缓存池睡眠； 程序开始时会先创建一个线程 M0，负责初始化和启动第一个 G，第一个 G 一般就是 main 函数； 每个 M 创建时会创建一个属于自己的 G0，负责调度，包括其他协程的切换等。 参考 [Go三关-典藏版] Golang调度器GPM原理与调度全分析 Go 语言设计与实现 6.5 调度器\n","wordCount":"1128","inLanguage":"en","datePublished":"2023-03-20T00:00:00Z","dateModified":"2023-03-20T00:00:00Z","author":{"@type":"Person","name":"往往不"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.wangwangbu.com/posts/tech/go-principle/b-go-gpm/"},"publisher":{"@type":"Organization","name":"往往不的攻略笔记","logo":{"@type":"ImageObject","url":"https://www.wangwangbu.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.wangwangbu.com/ accesskey=h title="数据源——往往不 (Alt + H)">数据源——往往不</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.wangwangbu.com/search title="🔍探索 (Alt + /)" accesskey=/><span>🔍探索</span></a></li><li><a href=https://www.wangwangbu.com/ title=🏠出生点><span>🏠出生点</span></a></li><li><a href=https://www.wangwangbu.com/posts title=📚升级><span>📚升级</span></a></li><li><a href=https://www.wangwangbu.com/archives title=📝存档><span>📝存档</span></a></li><li><a href=https://www.wangwangbu.com/tags title=🏷️词条><span>🏷️词条</span></a></li><li><a href=https://www.wangwangbu.com/about title=🧍‍♂️角色><span>🧍‍♂️角色</span></a></li><li><a href=https://www.wangwangbu.com/links title=🚘转生><span>🚘转生</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.wangwangbu.com/>🏠出生点</a>&nbsp;»&nbsp;<a href=https://www.wangwangbu.com/posts/>📚升级</a>&nbsp;»&nbsp;<a href=https://www.wangwangbu.com/posts/tech/>技巧 ➕</a></div><h1 class=post-title>Go原理：调度器和GPM模型</h1><div class=post-description>Go 的调度器原理学习记录，深入理解 GPM 模型，了解 Go 并发能力的来源。</div><div class=post-meta>📅&nbsp;<span title='2023-03-20 00:00:00 +0000 UTC'>2023-03-20</span>&nbsp;|&nbsp;✒️&nbsp;1128&nbsp;|&nbsp;⌛&nbsp;3分钟&nbsp;|&nbsp;📁&nbsp;编程
&nbsp;|&nbsp;🏷️&nbsp;<ul class=post-tags-meta><a href=https://www.wangwangbu.com/tags/go/>Go</a>
<a href=https://www.wangwangbu.com/tags/principle/>、principle</a>
<a href=https://www.wangwangbu.com/tags/%E8%B0%83%E5%BA%A6/>、调度</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>任务列表</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e5%99%a8 aria-label=调度器>调度器</a></li><li><a href=#gmp-%e6%a8%a1%e5%9e%8b aria-label="GMP 模型">GMP 模型</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>我们都知道 Goroutine 是 Go 的语言特色，也可以称之为协程。协程是运行在线程上的，而不同的协程和线程之间的调度则受“调度器”这一机制控制。</p><p>那么什么是调度器，它又是如何实现的呢？</p><h2 id=调度器>调度器<a hidden class=anchor aria-hidden=true href=#调度器>#</a></h2><p>我们追根溯源，了解一下调度器是如何出现的。</p><ol><li>早期单进程操作系统根本不需要调度器，进程遵循顺序执行，每个进程都要等上一个进程执行完才能执行。可是这样一个进程阻塞，后面的进程也无法执行。</li><li>后来有了多进程/多线程操作系统，一个进程阻塞可以让 CPU 执行别的进程，这就有了调度需求（Linux 中进程和线程等价控制）。但是进程间切换需要占用 CPU 资源，并且线程也占用较大内存（4MB）。</li><li>因为对于 CPU 来说只管理线程的调度即“内核态”，对每个线程绑定的用户空间或是说具体运行代码是什么样的并不关心，因此可以将这部分用户空间划分出来用户自己控制，就叫做协程，而“内核态”的线程也就是受 CPU 控制的那部分还叫做线程。</li></ol><p><strong>如果一个协程绑定一个线程</strong>，那协程的创建、删除和切换都是由 CPU 完成，代价太高；<strong>如果多个协程绑定一个线程</strong>，一旦某个协程阻塞，线程也会阻塞，其他协程也运行不了了。</p><p>因此使用多个协程绑定多个线程的模式，那协程的分配和线程的选择就需要中间有一个<strong>调度器</strong>的存在。</p><h2 id=gmp-模型>GMP 模型<a hidden class=anchor aria-hidden=true href=#gmp-模型>#</a></h2><p>调度器是一个组件，也是一种机制的实现。Go 语言的调度器是一个 GMP 模型。所谓 GMP 模型就是协程 G (Goroutine)，线程 M (thread) 以及处理器 P (Processor)。</p><p>你可能感到很疑惑，不是说协程和线程的事吗，怎么又冒出来个处理器。其实早期 Go 的调度器是没有处理器的，只有多个协程和一个全局 Goroutine 队列。但是这样就涉及到 Goroutine 的竞争，效率并不高。所以后来引入了处理器 P，以及它带着的本地 Goroutine 队列。</p><p>因此在 GMP 模型中，有一个装载 G 的全局队列，每个 P 还有一个装载 G 的本地队列。</p><p>我们打个比方，协程 G 就像是游戏里的任务，而线程 M 就是想做任务的玩家，而处理器 P 是各地任务大厅的 NPC。</p><p>M 需要做任务就要先找到一个 P 绑定，从它的本地队列接任务 G 做，做完（或是做一定时间）之后再接。</p><p>听上去很简单，也还有一些细节需要补充：</p><ol><li>P 是程序是程序启动时创建的，由环境变量控制数量；</li><li>M 绑定的 P 中如果没有 G 了，会从全局队列中找 G，没有的话会从其他 P 的本地队列偷一半 G 过来；</li><li>如果本地队列满了，再创建或执行完回来的 G 会放到全局队列；</li><li>如果 G 进入系统调用，M 会将它的 P 分给一个休眠队列的 M 或是新增一个 M；</li><li>G 的系统调用完毕，则会加入一个空闲的 P 中，没有则放入全局队列，M 则进入缓存池睡眠；</li><li>程序开始时会先创建一个线程 M0，负责初始化和启动第一个 G，第一个 G 一般就是 main 函数；</li><li>每个 M 创建时会创建一个属于自己的 G0，负责调度，包括其他协程的切换等。</li></ol><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><blockquote><p><a href=../https:/zhuanlan.zhihu.com/p/323271088 target=_blank rel=noopener>[Go三关-典藏版] Golang调度器GPM原理与调度全分析</a>
<a href=../https:/draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine target=_blank rel=noopener>Go 语言设计与实现 6.5 调度器</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.wangwangbu.com/tags/go/>Go</a></li><li><a href=https://www.wangwangbu.com/tags/principle/>principle</a></li><li><a href=https://www.wangwangbu.com/tags/%E8%B0%83%E5%BA%A6/>调度</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.wangwangbu.com/>往往不的攻略笔记</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>