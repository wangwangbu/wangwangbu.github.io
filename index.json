[{"content":"前言 文档： https://pkg.go.dev/sort\nGo 的 sort 包实现了四种排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法并不公开，由 Go 根据数据自行选择。\nsort 包提供了以下三种排序方法：\n基本类型切片排序； 自定义比较函数； 实现sort.Interface接口； 初次之外，sort 还提供了二分查找功能。\n基本类型排序 sort 提供对[]int切片、[]float64切片和[]string切片的排序，默认是从小到大。\n1 2 3 func Ints(x []int) func Float64s(x []float64) func Strings(x []string) 例如：\n1 2 nums := []int{5, 4, 3, 2, 1} sort.Ints(nums) // nums = [1, 2, 3, 4, 5] 那如果想从大到小排序怎么办，先将基本类型转化为实现了sort.Interface接口的对应类型IntSlice()、Float64Slice()或StringSlice()，然后使用Reverse()方法逆转接口的Less()方法，也就是排序顺序实现，最后使用通用排序方法Sort。\n例如：\n1 2 nums := []int{1, 2, 3, 4, 5} sort.Sort(sort.Reverse(sort.IntSlice(nums))) // nums = [5, 4, 3, 2, 1] 关于实现sort.Interface接口的排序方法，下文会详细介绍。\nsort 包为每个技术基础类型集合提供了方法来判断集合是否有序：\n1 2 3 func IntsAreSorted(x []int) bool func Float64sAreSorted(x []float64) bool func StringsAreSorted(x []string) bool 自定义比较函数 这应该是用的比较多，写起来也比较方便的方法，针对非基础类型的集合排序。主要使用Slice()方法：\n1 func Slice(x any, less func(i, j int) bool) x 是一个集合，一般是切片。比较函数以下标为入参，返回一个布尔值，可以将true看作是排在前面。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 people := []struct { Name string Age int }{ {\u0026#34;Bob\u0026#34;, 31}, {\u0026#34;John\u0026#34;, 42}, {\u0026#34;Michael\u0026#34;, 17}, {\u0026#34;Jenny\u0026#34;, 26}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u0026lt; people[j].Age }) // 按照年龄从小到大排序 相关的方法还有：\n1 2 unc SliceIsSorted(x any, less func(i, j int) bool) bool // 判断是否有序 func SliceStable(x any, less func(i, j int) bool) // 稳定排序 实现sort.Interface接口 这种方法可以对任意类型排序，还可以再包装让用户传入排序方法之类的，自由度比较高。\nsort.Interface接口有三个函数需要实现：\n1 2 3 func Len() int // 获取集合长度 func Less(i, j int) bool // 定义比较器 func Swap(i, j int) // 定义交换方法 任何实现了sort.Interface接口的类型都可以使用Sort方法排序。\n例如我们给一个People类型切片实现sort.Interface接口：\n1 2 3 4 5 type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u0026lt; a[j].Age } 然后就可以使用Sort排序：\n1 2 3 4 5 6 7 people := []Person{ {\u0026#34;Bob\u0026#34;, 31}, {\u0026#34;John\u0026#34;, 42}, {\u0026#34;Michael\u0026#34;, 17}, {\u0026#34;Jenny\u0026#34;, 26}, } sort.Sort(ByAge(people)) // 以年龄升序排序 对于sort.Interface接口类型，可以使用Reverse()方法逆序排序：sort.Sort(sort.Reverse(ByAge(people)))。\n使用sort.Stable能够稳定排序。\n二分查找 sort 包提供两类查找方法Search()和Find()，Find()在 Go 1.19 加入。查找的前提是集合有序。\nsort 包提供的Search()方法，对有序集合进行二分查找，找到满足要求的位置，我们先看函数定义：\n1 func Search(n int, f func(int) bool) int Search()在[0,n)范围内查找f(i)=true的最小索引ind。\nSearch()的返回值ind满足：对所有i\u0026lt;ind,比较函数f(i)=false，对所有i\u0026gt;=ind，比较函数f(i)=true。意思是ind是满足比较函数的第一个位置。如果都不满足，返回的就是n。\n例如找在升序切片data中找大于等于x的最小索引i：\n1 2 x := 23 i := sort.Search(len(data), func(i int) bool { return data[i] \u0026gt;= x }) 注意返回的是满足比较条件的位置，并不是如 Search 意思一样是找该指定数字索引。可能data中没有23这个数，例如[2, 3, 23, 25]和[2, 3, 24, 25]返回的是同一个位置，但第二个切片中并没有23。\n所以一般想实现二分查找获取该数的位置，还需要将返回位置的数字data[i]和x比较：\n1 2 3 4 5 6 if i \u0026lt; len(data) \u0026amp;\u0026amp; data[i] == x { // data[i] 就是要找的数字 x } else { // x 不在 data 中， // 但是 i 是一个可以加入 x 的位置，满足升序 } 同样的，sort 为基础数据类型切片也提供：\n1 2 3 func SearchFloat64s(a []float64, x float64) int func SearchInts(a []int, x int) int func SearchStrings(a []string, x string) int 因为Search()方法想实现其本意还需要判断，有人也提出了这个问题，于是 Go 团队在 Go 1.19 中加入了Find()方法来实现查找某个数的功能。我们可以看到他们关于这个问题的讨论： https://github.com/golang/go/issues/50340\nFind()方法定义如下：\n1 func Find(n int, cmp func(int) int) (i int, found bool) Find()使用二分查找找到切片[0,n)范围内满足cmp(i)\u0026lt;=0的最小索引i，标志found是当i\u0026lt;n并且cmp(i)=0时为真，也就是说目标值在切片中能被找到。找不到还是返回n。\n例如从升序切片中查找23：\n1 2 3 4 x := 23 i, found := sort.Find(data.Len(), func(i int) int { return data[i]-x }) found为真则说明找到data[i]=x，否则找到的就是可以插入的位置。\n","permalink":"https://www.wangwangbu.com/posts/tech/go-std/b-go-sort/","summary":"前言 文档： https://pkg.go.dev/sort Go 的 sort 包实现了四种排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法并不公开，由 Go 根据数据自行选择。 sort 包提供了以","title":"Go 标准库：sort"},{"content":"Cobr 是一个快速构建 CLI 应用程序的工具，也是一个生成应用程序和命令文件的程序。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-cobra/","summary":"Cobr 是一个快速构建 CLI 应用程序的工具，也是一个生成应用程序和命令文件的程序。","title":"Cobra"},{"content":"递归遍历 二叉树的递归遍历非常简单，前中后序的实现无非就是调用顺序的区别。Leetcode 上有对应练习：\n144.二叉树的前序遍历 94.二叉树的中序遍历 145.二叉树的后序遍历 不同顺序遍历的 Go 写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 前序 func preorderTraversal(root *TreeNode) []int { if root==nil { return []int{} } res := []int{root.Val} res = append(res, preorderTraversal(root.Left)...) res = append(res, preorderTraversal(root.Right)...) return res } // 中序 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } res := inorderTraversal(root.Left) res = append(res, root.Val) res = append(res, inorderTraversal(root.Right)...) return res } // 后序 func postorderTraversal(root *TreeNode) []int { if root==nil { return nil } res := []int{} res = append(res, postorderTraversal(root.Left)...) res = append(res, postorderTraversal(root.Right)...) res = append(res, root.Val) return res } 确实没啥难度，递归实现起来比较简单，但每次调用新的递归函数总是要分配内存，占用内存较多，因此非递归实现也有一定价值。\n非递归遍历 非递归遍历需要使用栈来保存之前的节点，以便回溯的实现。不同的顺序实现起来有所不同。\n前序遍历 前序遍历的非递归实现比较符合栈的常规使用，取出栈顶的节点，并将其左右节点入栈，其左右节点在之后就能访问，是一个从上到下拓展不需要回溯的过程。\n前序是中左右，因为栈是先进后出，所以需要先将右节点入栈，再将左节点入栈，这样就能先访问左节点再访问右节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func preorderTraversal(root *TreeNode) []int { stack := []*TreeNode{root} // root 入栈 num := []int{} for len(stack)\u0026gt;0 { cur := stack[len(stack)-1] // 取栈顶 cur stack = stack[:len(stack)-1] // 弹出 cur if cur==nil { // 因为在入栈的时候没有判断 nil continue // 就在取出的时候判断 } num = append(num, cur.Val) // 中 stack = append(stack, cur.Right, cur.Left) // 右节点左节点入栈 } return num } 中序遍历 中序遍历是左中右，需要先遍历完左子树之后才能记录当前节点，而且还需要判断有没有右子节点，之后进入右子节点。\n所以要先把遍历的节点入栈，在回溯到该节点即该节点出栈时才记录。先要沿着左边的路径走下去，这就需要一个指针来记录移动的位置。当指针无法再往左走时，说明要往上回溯，这时候开始处理其父节点，也就是堆顶元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func inorderTraversal(root *TreeNode) []int { stack := []*TreeNode{} res := []int{} cur := root for cur != nil || len(stack) != 0 { if cur != nil { // 如果不是 nil 先沿左子树向下 stack = append(stack, cur) // 将当前节点入栈保存 cur = cur.Left } else { // 如果当前节点是 nil 说明需要回溯 n := len(stack) cur = stack[n-1] // 回溯到父节点 stack = stack[:n-1] // 弹出父节点 res = append(res, cur.Val) cur = cur.Right // 进入右子树 } } return res } 后序遍历 后序遍历是左右中，而前序遍历是中左右，因此可以将前序遍历的加入左右节点的顺序反一下，实现中右左，再将得到的结果翻转就是左右中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func postorderTraversal(root *TreeNode) []int { stack := []*TreeNode{root} res := []int{} for len(stack)\u0026gt;0 { n := len(stack) cur := stack[n-1] stack = stack[:n-1] if cur==nil { continue } res = append(res, cur.Val) // 先加左再加右，访问顺序是先右后左 stack = append(stack, cur.Left, cur.Right) } // 翻转结果 for i, j:= 0, len(res)-1; i\u0026lt;j; i, j = i+1, j-1 { res[i], res[j] = res[j], res[i] } return res } ","permalink":"https://www.wangwangbu.com/posts/algo/tree/b-tree-traversal/","summary":"递归遍历 二叉树的递归遍历非常简单，前中后序的实现无非就是调用顺序的区别。Leetcode 上有对应练习： 144.二叉树的前序遍历 94.二叉树的","title":"二叉树的遍历"},{"content":"container/heap 文档： https://pkg.go.dev/container/heap\nheap 库包装了堆相关的方法，能够自动维护一个堆，需要我们实现一个接口供 heap 的方法调用：\n1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // 将 x 加到堆的 Len() 处 Pop() any // 堆顶位于 Len()-1，删除并返回该元素的值 } 可以看出该接口包含sort接口，因此还需要实现Less()、Len()、Swap()方法。\n假设我们使用一个Item类型的切片作为堆，可以这么定义：\n1 2 3 4 5 6 7 type myHeap []*Item func (mh myHeap) Len() int { return len(mh) } func (mh myHeap) Less(i, j int) bool { return mh[i].value\u0026lt;mh[j].value } func (mh myHeap) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] } Push()方法需要将添加的元素放在你的堆类型的 Len() 处，如果是队列的话就是放在队尾。Pop()方法需要将 Len()-1 处的元素删除并返回该元素值。\n简单的Push()和Pop()实现类似这样：\n1 2 3 4 5 6 7 8 9 10 11 12 func (mh *myHeap) Push(x interface{}) { item := x.(*Item) // 创建一个要保存的类型 *mh = append(*mh, item) // 放到 Len() 处，切片就可以用 append() } func (mh *myHeap) Pop() interface{} { old := *mh n := len(old) item := old[n-1] // 取 Len()-1 处元素 *mh = old[0:n-1] // 删除 Len()-1 处元素 return item } 注意：都是使用指针操作堆类型，这样才能确保更新。同时Push()的入参和Pop()的返回类型都是接口类型，才能正确实现。\n有人可能会觉得Pop()操作不应该弹出堆顶吗，有点反直觉，但其实heap.Pop()会先交换队首和队尾元素，再执行你实现的Pop()方法。\n在实现了堆接口类型后，我们就可以使用heap类型的方法实现堆操作了，heap会自己调用维护的方法。\nheap的方法如下，其中h是接口类型的指针，不然和我们定义的Push()和Pop()接收者对不上：\n1 2 3 4 5 func Init(h Interface) // 将 h 初始化成一个堆 func Push(h Interface, x any) // 给堆 h 添加元素 x func Pop(h Interface) any // 从堆 h 弹出堆顶 func Fix(h Interface, i int) // 调整 i 处元素，可在更新该元素后调用 func Remove(h Interface, i int) any // 删除 i 处元素，返回该值 关于 heap 具体实现方法，可以看[[b-go-source-heap]]或 https://ieevee.com/tech/2018/01/29/go-heap.html\n","permalink":"https://www.wangwangbu.com/posts/tech/go-std/b-go-heap/","summary":"container/heap 文档： https://pkg.go.dev/container/heap heap 库包装了堆相关的方法，能够自动维护一个堆，需要我们实现一个接口供 heap 的方法调用： 1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // 将 x 加到堆的 Len() 处 Pop() any // 堆","title":"Go 标准库：container/heap"},{"content":"container/list 文档： https://pkg.go.dev/container/list\nlist 是一个双向链表，其中每个元素是 Element 类型：\n1 2 3 type Element struct { Value interface{} } 可用(*Element)Next方法和(*Element)Prev方法获取前后元素。\nList 类型表示双链表，通过list.New()新建指向该类型的指针，有以下方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (l *List) Back() *Element // 返回最后一个元素 func (l *List) Front() *Element // 返回第一个元素 func (l *List) Init() *List // 初始化或清空 // 添加值 v 到 mark 后面并返回添加的元素指针 func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 添加值 v 到 mark 前面并返回添加的元素指针 func (l *List) InsertBefore(v interface{}, mark *Element) *Element func (l *List) Len() int // 返回元素数量，O(1) func (l *List) MoveAfter(e, mark *Element) // 将 e 移动到 mark 后面 func (l *List) MoveBefore(e, mark *Element) // 将 e 移动到 mark 前面 func (l *List) MoveToBack(e *Element) // 将 e 移动到链表末尾 func (l *List) MoveToFront(e *Element) // 将 e 移动到链表开头 func (l *List) PushBack(v interface{}) *Element // 在末尾插入值 v 并返回元素指针 func (l *List) PushBackList(other *List) // 在末尾插入链表副本 func (l *List) PushFront(v interface{}) *Element // 在开头插入值 v 并返回元素指针 func (l *List) PushFrontList(other *List) // 在开头插入链表副本 func (l *List) Remove(e *Element) interface{} // 删除 e 返回 e 的值 ","permalink":"https://www.wangwangbu.com/posts/tech/go-std/b-go-list/","summary":"container/list 文档： https://pkg.go.dev/container/list list 是一个双向链表，其中每个元素是 Element 类型： 1 2 3 type Element struct { Value interface{} } 可用(*Element)Next方法和(*Element)Prev方法","title":"Go 标准库：container/list"},{"content":" 题目链接： https://leetcode.cn/problems/top-k-frequent-elements/\n思路 题目意思相当于对于给定数组，找到最大的前 K 个。\n最无脑的方法是排序完再找返回前 K 个，时间复杂度是 O(nlogn)，虽然在一般题目中算是一个优秀的时间复杂度，在这题只能算是最基础的方法。\n研究小于 O(nlogn) 的解法。\n方法一：小根堆 因为是找前 K 大，自然想维护一个包含 K 个元素的集合，每次遍历到新元素 x，就和集合中最小的元素 y 比较。如果 x\u0026gt;y，当然可以取代 y 的加入集合。\n这个思路的关键就是怎么快速的找到每次加入新元素后，集合的最小值 y。\n因此可以使用小根堆来维护，将最小值放在堆顶，每次比较和替换是 O(1) 复杂度，替换后调整是 O(logK) 复杂度（因为堆是保持 K 个元素）。\n遍历一遍之后，堆里 K 个元素就是所求前 K 大，时间复杂度是 O(nlogK)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // Top K using heap type num struct { key int freq int } // 实现一个堆接口 type myHeap []*num func (mh myHeap) Len() int { return len(mh) } func (mh myHeap) Less(i, j int) bool { return mh[i].freq\u0026lt;mh[j].freq } func (mh myHeap) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] } func (mh *myHeap) Push(x interface{}) { xNum := x.(*num) *mh = append(*mh, xNum) } func (mh *myHeap) Pop() interface{} { old := *mh n := len(old) item := old[n-1] *mh = old[0:n-1] return item } func topKFrequent(nums []int, k int) []int { tMap := make(map[int]int, len(nums)) for _, x := range nums { tMap[x]++; } var arr myHeap heap.Init(\u0026amp;arr) for key, freq := range tMap { if len(arr)\u0026lt;k { heap.Push(\u0026amp;arr, \u0026amp;num{key, freq}) } else if arr[0].freq\u0026lt;freq { heap.Pop(\u0026amp;arr) heap.Push(\u0026amp;arr, \u0026amp;num{key, freq}) } } res := []int{} for len(arr)\u0026gt;0 { res = append(res, heap.Pop(\u0026amp;arr).(*num).key) } return res } 方法二：哈希 在统计完每个数出现的频次后，可以根据频次将每个数哈希到一个表中，每个频次用链表存储，因为题目描述里说数组最长也就$10^5$，开个这么大的表绰绰有余。哈希完再从高到低将链表中的元素加入答案，只用加 K 个就好。\n这种做法时间开销是 O(n)，但空间开销也是 O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // Top K using hash func topKFrequent(nums []int, k int) []int { tMap := make(map[int]int, len(nums)) for _, x := range nums { tMap[x]++; } fMap := make(map[int]*list.List, 100005) max := 0 // 记录最大频次 max 可以节省一点循环次数 for key, freq := range tMap { ll := fMap[freq]; if ll == nil { ll = list.New() fMap[freq] = ll if freq \u0026gt; max { max = freq } } ll.PushBack(key) } ind := 0 res := make([]int, k) Loop: for i:=max; i\u0026gt;=0; i-- { if ll, ok := fMap[i]; ok { for ele:=ll.Front(); ele!=nil; ele=ele.Next() { if ind\u0026lt;k { res[ind] = ele.Value.(int) ind++ } else { break Loop } } } } return res } 方法三：快排 Top K 的经典算法就是利用快排，在快排每次划分左右两边之后，只需要在一边递归下去。\n假设我们使用索引$i$作为比较的元素，将比$i$对应元素大的放在$i$左边，将比$i$对应元素小的放$i$右边。假设$i$左边有$h$个元素，分下列几种情况处理：\n$k\u0026lt;h$，说明只用在左边递归去找。 $k\\geq h$，说明$i$左边$h$个一定是 Top K，先将他们加入集合，再在右边递归去找 Top k-h 就行了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Top K with qsort type num struct { key int freq int } // 需要提供 start 和 end 来确定递归处理的边界 func findTopK(arr []*num, res []int, start, end, k, retIndex int) { rand.Seed(time.Now().UnixNano()) mid := rand.Int()%(end-start+1)+start arr[mid], arr[start] = arr[start], arr[mid] midValue := (*arr[start]).freq index := start for i:=index+1; i\u0026lt;=end; i++ { if (*arr[i]).freq\u0026gt;midValue { arr[i], arr[index+1] = arr[index+1], arr[i] index++ } } arr[index], arr[start] = arr[start], arr[index] if k\u0026lt;=index-start { findTopK(arr, res, start, index-1, k, retIndex) } else { for i:=start; i\u0026lt;=index; i++ { res[retIndex] = (*arr[i]).key retIndex++ } if k \u0026gt; index-start+1 { findTopK(arr, res, index+1, end, k-(index-start+1), retIndex) } } } func topKFrequent(nums []int, k int) []int { tMap := make(map[int]int, len(nums)) for _, x := range nums { tMap[x]++; } var arr []*num for k, v := range tMap { arr = append(arr, \u0026amp;num{k, v}) } res := make([]int, k) findTopK(arr, res, 0, len(arr)-1, k, 0) return res } 需要注意的是，保存结果的切片res是作为函数入参的，在topKFrequent中分配了大小，在findTopK中使用retIndex作为下标赋值，这样切片对应的数组地址没有变化，因此可以保证正确性。如果在findTopK中使用append方法，在扩容后数组地址发生变化，也就不正确了，希望使用append方法则需要传入切片指针。\n","permalink":"https://www.wangwangbu.com/posts/algo/leetcode/b-leetcode-347/","summary":"题目链接： https://leetcode.cn/problems/top-k-frequent-elements/ 思路 题目意思相当于对于给定数组，找到最大的前 K 个。 最无脑的方法是排序完再找返回前 K 个，时间复杂度是 O(nlogn)，虽然在一般题","title":"Leetcode 347 前 K 个高频元素"},{"content":"欧盟通用保护条例 General Data Protection Regulation 简称 GDPR，于 2018 年 5 月 25 日正式实施。\n个人数据指任何用来识别活着的人/自然人的数据（例如姓名、邮箱、IP、网络 ID） 关注对个人数据的处理（记录、保存、下载、组织、改变或分享） 定义敏感数据，例如人种、健康情况、政治观点 包含数据主体（欧盟公民）、数据控制者、数据处理者（收集或处理数据） 数据主体有权清除、更正、拷贝数据，有权反对对其个人数据的处理，要求停止处理个人数据。\n只允许在欧盟批准的或遵循欧盟建议的合同条款的国家或地区间转移数据，不包括中国。\n如果数据泄露，对用户产生不利影响，企业必须在 72 小时报告。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-gdpr/","summary":"欧盟通用保护条例 General Data Protection Regulation 简称 GDPR，于 2018 年 5 月 25 日正式实施。 个人数据指任何用来识别活着的人/自然人的数据（例如姓名、邮箱、IP、网络 ID）","title":"通用数据保护条例"},{"content":"不经意传输（Oblivious Transfer, OT）使得服务发送方和服务接收方以不经意的方式交互信息。\n基于 RSA 实现：\n发送者生成两个 RSA 公私钥对发给 B; B 生成随机数 r，根据想要的消息（$m_0$ 或 $m_1$）选择对应的公钥加密 r，将密文 c 发给 A。 A 使用两个私钥解密出$k_0$和$k_1$，并和对应消息异或生成掩码： $$e_0=k_0\\oplus m_0$$ $$e_1=k_1\\oplus m_1$$ B 用随机数 r 和掩码异或，得到一条是正确的，一条是随机数。 ","permalink":"https://www.wangwangbu.com/posts/zettel/z-oblivious-transfer/","summary":"不经意传输（Oblivious Transfer, OT）使得服务发送方和服务接收方以不经意的方式交互信息。 基于 RSA 实现： 发送者生成两个 RSA 公私钥对发给 B; B 生成随机","title":"不经意传输"},{"content":"同态加密（Homomorphic Encryption, HE）是在密文上通过计算获取期望的明文计算结果。\n半同态：只支持密文上的加法或乘法操作。 全同态：既支持密文上的加法也支持乘法。\nRSA 是同态乘法，Paillier 是同态加法，一般半同态就够用。\n全同态计算会有噪声，随计算进行增加，Bootstrapping 方法希望计算完几轮后就解密消除噪声，解密通过同态计算解密电路来实现，但密文大小会不断膨胀。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-homomorphic-encryption/","summary":"同态加密（Homomorphic Encryption, HE）是在密文上通过计算获取期望的明文计算结果。 半同态：只支持密文上的加法或乘法操作。 全同态：既支持密文上","title":"同态加密"},{"content":"混淆电路（Garbled Circuit, GC）解决各自持有隐私数据，在不泄露自己数据的前提下共同计算结果。主要是对输入线的不同可能生成不同的 key 来混合加密真值表，使用 OT 根据另一方输入值传输对应密钥。另一方用密钥对密文解密。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-garbled-circuit/","summary":"混淆电路（Garbled Circuit, GC）解决各自持有隐私数据，在不泄露自己数据的前提下共同计算结果。主要是对输入线的不同可能生成不同的 key 来混合加密真","title":"混淆电路"},{"content":"秘密共享（Secret Sharing, SS）将一个数字拆成多个数，并发给多个参与方，一个或少数几个无法还原数据。\n任意 t 个参与方可得明文，任意不多于 t-1 个参与方无法得出。构造一个 t-1 次多项式： $$f(x)=a_0+a_1x+a_2x^2+\\cdots+a_{t-1}x^{t-1}$$ 其中$a_0$为隐私数字$s$，$a_1,a_2,\\ldots,a_{t-1}$为随机数，n 个份额分别是$f(1),f(2),\\ldots,f(n)$，满足加法同态。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-secret-sharing/","summary":"秘密共享（Secret Sharing, SS）将一个数字拆成多个数，并发给多个参与方，一个或少数几个无法还原数据。 任意 t 个参与方可得明文，任意不多于 t-1 个参与","title":"秘密共享"},{"content":"零知识证明（Zero-Knowledge Proof, ZKP）解决的问题是在不提供答案的基础上向另一方证明自己知道答案。可用于区块链证明交易合规，MPC用来防止偏离协议发送假数据的恶意节点。\n需要满足完备性、可靠性、零知识性。\n证明方先根据论断内容向验证方发个交底材料，这个样例论断需要是随机的或加密的； 验证方随机生成一个试探（学术名词是挑战，challenge），发给证明方； 证明方根据该试探和交底材料生成证明信息发给验证方。验证方自己将信息和交底材料一合计，判断证明方是否通过了该试探。 ","permalink":"https://www.wangwangbu.com/posts/zettel/z-zero-knowledge-proof/","summary":"零知识证明（Zero-Knowledge Proof, ZKP）解决的问题是在不提供答案的基础上向另一方证明自己知道答案。可用于区块链证明交易合规，MPC","title":"零知识证明"},{"content":"安装 在 官网下载页选择要下载的版本，右键复制下载地址：\n然后使用wget下载：\n1 wget https://go.dev/dl/go1.20.2.linux-amd64.tar.gz 下载完解压，一般是放在usr/local目录下：\n1 sudo tar -C /usr/local/ -xzf go1.17.8.linux-amd64.tar.gz 使用ls -F /usr/local/go可以查看安装目录下文件：\n环境变量配置 需要将 Go 的路径添加到环境变量中，在/etc/profile.d/go.sh文件中添加（使用 vim 修改sudo vim /etc/profile.d/go.sh）：\n1 2 3 4 5 export GOROOT=/usr/local/go export GOPATH=/data/go export PATH=$PATH:$GOROOT/bin:$GOPATH export GO111MODULE=\u0026#34;on\u0026#34; # 开启 Go moudles 特性 export GOPROXY=https://goproxy.cn,direct # 安装 Go 模块时，国内代理服务器设置 然后加载配置立即生效：\n1 source /etc/profile 使用go version验证是否安装成功。\n在 VSCode 中打开.go文件会提醒安装 Go 的一些工具，点击确定即可安装，或者自己使用go get自行选择安装。\n如果使用的是 WSL 或远程服务器，可能需要在 VSCode 中手动搜索 Go 插件，选择在远程服务器安装。\n","permalink":"https://www.wangwangbu.com/posts/tech/linux-config/linux-go/b-linux-go/","summary":"安装 在 官网下载页选择要下载的版本，右键复制下载地址： 然后使用wget下载： 1 wget https://go.dev/dl/go1.20.2.linux-amd64.tar.gz 下载完解压，一般是放在usr/local目录下： 1 sudo tar -C /usr/local/ -xzf","title":"Linux 下 Go 安装与设置"},{"content":"Memcached 是一套分布式高速缓存系统，是基于内存的 key-value 存储。Groupcache 是同一作者开发的 Go 语言版本。\nMemcached 的优点：\n协议简单 基于 libevent 事件处理（libevent 封装了一些操作系统指令，在 linux 等上性能好） 内置内存存储方式（提高性能，但重启数据丢失） 不互相通信的分布式 Groupcache 的特点：\n不需要对服务器单独设置，既是客户端也是服务端。 具有缓存过滤机制，防止缓存击穿。 只有淘汰是而不能更新。 自动备份“超热”项，防止过载。 最大的区别是 memcache 有缓存过期策略，groupcache 没有缓存有效期和过期策略。memcache 服务器之间是没有交集的，在 groupcache 则是集群起来的。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-memcached%E5%92%8Cgroupcache/","summary":"Memcached 是一套分布式高速缓存系统，是基于内存的 key-value 存储。Groupcache 是同一作者开发的 Go 语言版本。 Memcached 的优点： 协议简单 基于 libevent 事件处理（libev","title":"Memcached 和 Groupcache"},{"content":" 对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。\n数据库 面向对象编程语言 表(table) 类(class/struct) 记录(record,row) 对象(object) 字段(field,column) 对象属性(attribute) ","permalink":"https://www.wangwangbu.com/posts/zettel/z-orm/","summary":"对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关","title":"ORM"},{"content":"SQLite 是一款轻量级的，遵守 ACID 事务原则的关系型数据库，可以直接嵌入到代码中，不需要启动额外的服务，SQLite 将数据存储在单一的磁盘文件中。\nLinux 安装：apt-get install sqlite3\n命令速查： https://geektutu.com/post/cheat-sheet-sqlite.html\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-sqlite/","summary":"SQLite 是一款轻量级的，遵守 ACID 事务原则的关系型数据库，可以直接嵌入到代码中，不需要启动额外的服务，SQLite 将数据存储在单一的磁盘文件中。 Linux 安装","title":"SQLite"},{"content":"Protocol Buffers（protobuf）是一种以二进制方式存储的结构化数据存储格式，占用空间小，可读性差，多用于 RPC 数据格式。在.proto文件中定义结构化数据，可以通过protoc转化成多种语言代码。\n安装使用参照：https://geektutu.com/post/quick-go-protobuf.html\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-protobuf/","summary":"Protocol Buffers（protobuf）是一种以二进制方式存储的结构化数据存储格式，占用空间小，可读性差，多用于 RPC 数据格式。在.proto文件中","title":"Protocol Buffers"},{"content":"对于给定的 key，使用哈希值确定获取资源的节点，防止不同节点重复缓存同一资源。一致性哈希将 key 和节点都映射到 2^32 的环形空间，使用顺时针找到的第一个节点获取 key 对应的值。节点的增删只影响周围的一小部分数据。\n使用一般哈希算法，节点数量变化时，会引起缓存雪崩，详见[[z-缓存问题]]。\n如果节点过少，会出现负载不均的问题，称为数据倾斜。为了解决这一问题，引入虚拟节点，一个真实节点对应多个虚拟节点。当找到虚拟节点时，使用对应的真实节点。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/","summary":"对于给定的 key，使用哈希值确定获取资源的节点，防止不同节点重复缓存同一资源。一致性哈希将 key 和节点都映射到 2^32 的环形空间，使用顺时针找到的第一","title":"一致性哈希"},{"content":" 缓存雪崩：缓存在同一时刻全部失效，造成瞬时 DB 请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。\n缓存击穿：一个存在的 key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时 DB 请求量大、压力骤增。\n缓存穿透：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/","summary":"缓存雪崩：缓存在同一时刻全部失效，造成瞬时 DB 请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起","title":"缓存问题"},{"content":" FIFO (First In First Out): 先进先出，淘汰缓存中最早添加的，用队列可以实现。 LFU (Least Frequently Used): 最少使用，淘汰缓存中访问频率最低的，维护一个按访问次数排序的队列。 缺点是受历史数据影响较大，某个数据可能在一个时间之后不再访问，但之前的访问次数会使其一直不被淘汰。 LRU (Least Recently Used): 最近最少使用，维护一个队列，将被访问的记录移到队尾，一直淘汰队首。 [[Q-LRU-LFU]]\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/","summary":"FIFO (First In First Out): 先进先出，淘汰缓存中最早添加的，用队列可以实现。 LFU (Least Frequently Used): 最少使用，淘汰缓存中访问频率最低的，维护一个按访问次数排序的队列。 缺点是受","title":"缓存淘汰策略"},{"content":" Dendron 是一个开源的、本地优先的、基于 Markdown 的笔记工具，它是专为开发人员构建的个人知识管理解决方案（PKM），可以与 VS Code 和 VSCodium 等 IDE 原生集成。\n和 Foam 的主要区别就是 Dendron 集成了各种功能，包括 Markdown、分层次、发布等，是一个独立的笔记软件，Foam 可以看作是支持双链的插件。\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-dendron/","summary":"Dendron 是一个开源的、本地优先的、基于 Markdown 的笔记工具，它是专为开发人员构建的个人知识管理解决方案（PKM），可以与 VS Code 和 VSCodium 等 IDE 原生集成。 和 Foam 的主要区","title":"Dendron"},{"content":"想法 VSCode 的终端会调用电脑装好的 shell，例如 cmd 和 Win10 自带的 PowerShell，想要美化就得从 shell 入手。关于这个 Win10 下有两套方案：\n使用zsh。安装 WSL，在 Ubuntu 子系统中使用 oh-my-zsh 配置 zsh 命令解释器，然后在 VSCode 中安装 Remote-WSL 插件，连接子系统从而使用 zsh，属于是曲线救国。 使用PowerShell。微软的 PowerShell 也可也安装模组提升体验，使用 oh-my-posh 或是 starship 来美化命令行，使用 PSReadline 来优化操作。 第一种方法可以查看[[b-linux-terminal]]，本文主要介绍第二种。\n美化命令行 准备 Win10 自带的 PowerShell 应该是 5.x 版本，可能不支持一些 Module 的效果，因此先安装最新版本的 PowerShell（ github下载地址）。使用默认地址安装，千万不要改地址，会导致后续无法识别。\n也可以使用winget安装，更方便之后的更新等操作：\n1 winget install Microsoft.PowerShell 安装完后Win+R使用指令pwsh打开。VSCode 默认打开终端也是最新版，我们只用在一个地方配置好即可。\n在配置之前，推荐尝试微软的新终端 Windows Terminal，可配置高颜值，在微软商店就能下载。正常打开就能看到自带PowerShell和安装好的最新版，我们设置默认打开最新版。\n不知道什么原因我另一台电脑只有识别到老版 PowerShell，因此我在终端设置中将老版的可执行文件地址改为新版地址（默认安装地址是C:\\Program Files\\PowerShell\\7\\pwsh.exe）。\n设置完重启终端就能查看到。\n安装模组 首先，前文提到的 PSReadline 随最新版 PowerShell 附赠，不用特意安装。使用Get-Module指令就可以查看安装好的模组列表。在 PowerShell 中安装 posh-git 和 oh-my-posh：\n1 2 Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 其中安装的 oh-my-posh 在执行Import-Module oh-my-posh时提示不成功，需要按照 官网指引进行安装。指引中可以使用以下两条命令任选一条进行安装：\n1 2 3 winget install JanDeDobbeleer.OhMyPosh #winget # or scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json #scoop oh-my-posh 的默认版本是高于 2 的，是以 Go 语言编写，适用于多平台。虽然看到说法是 v2 版本打开速度更快，但现在版本有更丰富的主题选择，可以根据个人需求选择。\n接下来设置配置各个模组。\n设置 PSReadline 对模组的设置可以编辑设置文档，打开方式：\n1 notepad $Profile 一开始没有可能会提醒新建一个，点击确定即可。\n在文件中输入以下指令设置 PSReadline：\n1 2 3 4 5 6 Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录 Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # tab 显示命令菜单 Set-PSReadLineKeyHandler -Key \u0026#34;Ctrl+z\u0026#34; -Function Undo # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录 这些设置都可以参考 官方文档按需求进行修改。\n设置oh-my-posh 使用 以前使用Import-Module oh-my-posh可以导入，但按照最新文档，需要使用：\n1 oh-my-posh init pwsh | Invoke-Expression posh-git 模块仍然可以使用Import-Module posh-git导入。\n添加并保存好设置文档后，重启终端，可以看到乱码但有颜色的命令行。接下来需要添加 Nerd Fonts 字体。\n可以从 Nerd Fonts网站选择喜欢的下载安装，我使用的是 Jetbrains 的 JetBrainsMono Nerd Font，下载的压缩包里可能有很多字体，选择一款 Windows Compatible 的安装即可。\n安装后在终端设置里的默认值外观设置该字体，保存设置切回去就能看到好看的样式。\n输入Get-PoshThemes查看已经预载的样式，我这里使用的是 powerlevel10k_classic 主题。参照 官网文档，使用 winget 安装的话需要修改启动指令为：\n1 oh-my-posh init pwsh --config $env:POSH_THEMES_PATH\\powerlevel10k_classic.omp.json | Invoke-Expression 使用 scoop 安装的话则需要修改启动指令为：\n1 oh-my-posh init pwsh --config \u0026#34;$(scoop prefix oh-my-posh)\\themes\\jandedobbeleer.omp.json\u0026#34; | Invoke-Expression 重启终端就能看到新主题。\n自定义主题 因为我是通过Powershell Module的形式安装，用指令导出主题无效，只好采用手动复制的方式。\n如上设置所示，主题都被存放在$env:POSH_THEMES_PATH\\中，Windows下地址为C:\\Users\\(user_name)\\AppData\\Local\\Programs\\oh-my-posh\\themes。\n复制想要修改的主题，修改后在设置文档中改为自己的主题名即可。\n我主要添加对 conda 的显示。\n支持conda等环境：\n参考 文档对 Python 类型 Segment 的设置，将desplay_mode属性设置为environment，只有使用虚拟环境时才显示 Python 信息。\n设置的样式如下\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#546E7A\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#98C379\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;display_default\u0026#34;: true, \u0026#34;display_mode\u0026#34;: \u0026#34;environment\u0026#34; }, \u0026#34;template\u0026#34;: \u0026#34;\\uE235 {{ if .Error }}{{ .Error }}{{ else }}{{ if .Venv }}{{ .Venv }}({{ end }}{{ .Full }}{{ end }}) \u0026#34; }, 加载太慢问题 参考：https://wdd.js.org/posts/2022/07/igur01/\n设置Vi编辑模式 如果想使用 Vim 模式操作命令行，PSReadline 也提供方法，在设置文档中添加:\n1 Set-PSReadlineOption -EditMode Vi # 设置Vim编辑模式 单单这样设置，插入模式和正常模式切换都是竖线光标，无法区分，添加以下代码区分不同模式光标:\n1 2 3 4 5 6 7 8 9 10 function OnViModeChange { if ($args[0] -eq \u0026#39;Command\u0026#39;) { # Set the cursor to a blinking block. Write-Host -NoNewLine \u0026#34;`e[1 q\u0026#34; } else { # Set the cursor to a blinking line. Write-Host -NoNewLine \u0026#34;`e[5 q\u0026#34; } } Set-PSReadLineOption -ViModeIndicator Script -ViModeChangeHandler $Function:OnViModeChange 玄学问题：这部分代码要放到之前 PSReadline 的设置上面，否则tab功能会失效，应该是被覆盖了。\n美化 VSCode Terminal 以上步骤设置好，基本打开 VSCode 的终端就是设置好的 PowerShell，这里再提醒一下，安装PowerShell的时候一定要使用默认地址，否则这里会找不到最新版。\n还需要设置终端字体，在设置的terminal.integrated.fontFamily中设置，我设置为JetBrainsMono NF。\n美化 Windows Terminal 未完待续。。。\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-configuration/vscode-terminal/b-vscode-terminal/","summary":"想法 VSCode 的终端会调用电脑装好的 shell，例如 cmd 和 Win10 自带的 PowerShell，想要美化就得从 shell 入手。关于这个 Win10 下有两套方案： 使用zsh。安装","title":"Win10 VSCode 终端美化"},{"content":"前置工作 需要先启动 Windows 上 WSL的相关服务：以管理员身份启动 PowerShell，输入以下命令：\n1 2 3 4 # 开启 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # 开启 Hyper-V 功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 会提示设置重启生效，可以等下一步完成一起重启，接下来安装 Linux 的发行版本。\n安装 可以在 Microsoft 商店选择喜欢的 Linux 版本，包括 Ubuntu、SUSE、Kali等，或是使用命令wsl --install就可完成，但一般默认装在 C 盘。\n想装在其他盘可以使用下面的方法，以 Ubuntu 20.04 为例。\n下载并安装 WSL 2 内核更新包：https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\n选择或创建一个你喜欢的目录，例如D:\\Linux，输入命令下载安装 Ubuntu 20.04。\n1 Invoke-WebRequest -Uri https://wsldownload.azureedge.net/Ubuntu_2004.2020.424.0_x64.appx -OutFile Ubuntu20.04.appx -UseBasicParsing 可以看到D:\\Linux目录下有一个Ubuntu20.04.appx，然后执行下面的命令：\n1 2 Rename-Item .\\Ubuntu20.04.appx Ubuntu.zip Expand-Archive .\\Ubuntu.zip -Verbose 此时 Ubuntu 20.04 就安装完成了，重启之后在命令行输入：\n1 2 # 设置 WSL 2 wsl --set-default-version 2 双击D:\\Linux\\Ubuntu目录下的ubuntu2004.exe即可启动 Ubuntu，一开始会安装一些包和让你设置用户名密码。有问题可以先重启尝试解决。\n第一次成功启动后，在微软的“终端”应用中已经可以新建 WSL 连接。\n使用 root 在用户下使用总是有诸多不便，还是建议使用 root 账户。\n正常 root 是没有密码的，也可以设置密码：\n1 sudo passwd root 需要输入当前用户密码，再输入两次 root 密码完成设置，重启服务之后就可以切换到 root 账户：\n1 su root 但是不知道是因为工作区限制还是什么问题，在 VSCode 中无法完成切换，于是直接设置启动时以 root 连接。\n在 WSL 的安装目录下，以管理员身份启动 PowerShell，输入：\n1 ./ubuntu2004.exe config --default-user root 再启动 WSL 就是以 root 身份登入，无效就使用wsl --t Ubuntu20.04关闭再进入。\n更换 apt 源 Ubuntu 使用 apt 安装应用，因为网络问题需要给 apt 换成国内的源，如阿里云源或清华源。\n首先备份一下源文件，将sources.list拷贝一份sources.list.bak：\n1 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 然后打开sources.list文件进行修改，使用 vim 或 nano 等编辑器都可，这里使用 vim，按i进入编辑模式。\n1 sudo vim /etc/apt/sources.list 打开之后添加源地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse #添加清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse 修改完保存退出，vim 按Esc退出编辑模式后，输入:wq保存退出，nano 使用Ctrl+O保存Ctrl+X退出。\n换源后更新源：\n1 sudo apt-get update 更新软件，显示我有 579 个可更新，还是花了一点时间，可以用到时再更新：\n1 sudo apt-get upgrade 问题 WSL 安装怎么可能那么顺利，还是遇到一些问题。\n更新源不成功 在给 apt 换源后更新源会报错，可能是Failed to fetch的报错，也可能是证书问题Certificate verification failed，需要使用对应的方法解决。\nFetch 失败：\n一般是 DNS 服务器问题，默认 WSL 使用的本机连接 DNS 服务器，不行的话需要修改。\nUbuntu 的配置文件在/etc/resolv.conf（注意不是resolve），可以使用cat /etc/resolv.conf命令查看，文件头就写着“该文件自动生成，取消自动生成应该。。。”。为了我们的设置不在重启后被覆盖，就按他说的设置/etc/wsl.conf文件。\n使用vim打开/etc/wsl.conf，在文件中添加：\n1 2 [network] generateResolvConf=false 注意是...Resolv...，保存关闭。\n然后就可以设置/etc/resolv.conf文件了：\n1 sudo vim /etc/resolv.conf 添加你想要的 DNS 服务器地址，例如：\n1 nameserver 8.8.8.8 也可以添加别的：阿里云223.6.6.6，223.5.5.5，腾讯119.29.29.29。\n保存退出之后再使用更新源就行了，即使下次重启 WSL 之后配置也不会修改。\n如果遇到无法保存的错误\u0026quot;Can\u0026rsquo;t open linked file for writing\u0026quot;，此时resolv.conf是一个链接，尝试删除之后再用 vim 新建文件：\n1 2 3 4 # 删除文件 sudo rm /etc/resolv.conf # 再次编辑 sudo vim /etc/resolv.conf 参考：https://www.zhihu.com/question/421854017\n证书验证失败：\ndate查看时间是否正确，排除时间造成的证书问题。 通过sudo apt install ca-certificates --reinstall无法更新安装包。 手动下载ca-certificates.deb文件重新安装最新版。 文件从 此处下载，选择对应 Linux 版本，例如我是 Ubuntu 20.04 LTS (Focal Fossa)，选择一个最新版点击：\n网页拉到下面有一个安装地址：\n在 Ubuntu 终端我们进到tmp目录下载下来：\n1 2 cd /tmp wget http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20211016ubuntu0.20.04.1_all.deb 如果提示以下错误，可以先尝试配置 DNS 服务器，见上一条Fetch 失败的方法，然后使用apt安装：sudo apt install ca-certificates --reinstall\n如果成功下载下来，使用dpkg命令安装：\n1 dpkg -i ./ca-certificates_20211016ubuntu0.20.04.1_all.deb 再使用sudo apt-get update试试。\n参考：https://juejin.cn/post/7033412379727626247\n","permalink":"https://www.wangwangbu.com/posts/tech/wsl/b-wsl/","summary":"前置工作 需要先启动 Windows 上 WSL的相关服务：以管理员身份启动 PowerShell，输入以下命令： 1 2 3 4 # 开启 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # 开启 Hyper-V 功能 dism.exe /online","title":"WSL 2 的安装与配置"},{"content":"GOPATH 是老版本的包管理模式，之后是 Go Vendor，Go Module 是新的方式。Go Vendor 是将所有包放在 vendor 目录下，Go Module 会将依赖安装在GOPATH/pkg/mod中，和当前项目分离。需要将依赖安装在当前地址时可以用go mod vendor来安装在 vendor 目录下。\n详细介绍 Go Module 和 Go Vendor\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-go-module/","summary":"GOPATH 是老版本的包管理模式，之后是 Go Vendor，Go Module 是新的方式。Go Vendor 是将所有包放在 vendor 目录下，Go Module 会将依赖安装在GOPATH/pkg/mo","title":"Go Module"},{"content":"差分隐私（Differential Privacy, DP）保护数据源的改动导致的隐私泄露问题。\n对于一个随机化算法$F$，两个相邻数据集$D$和$D^\\prime$需要满足： $$Pr{F(D)=O}\\leq e^\\varepsilon\\cdot Pr{F(D^\\prime)=O}$$\n可以加拉普拉斯噪音（Laplace noise）掩盖具体数值，一种放宽的定义： $$Pr{F(D)=O}\\leq e^\\varepsilon\\cdot Pr{F(D^\\prime)=O}+\\delta$$\n对于这种可以加高斯噪声（Gaussian noise）。\nDifference privacy is a technique for resisting the adversary inferring the information of database though the change.\nLaplace distribution is a popular noise added to the database for insuring DP.\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-differential-privacy/","summary":"差分隐私（Differential Privacy, DP）保护数据源的改动导致的隐私泄露问题。 对于一个随机化算法$F$，两个相邻数据集$D$和$D^\\pri","title":"差分隐私"},{"content":"前言 之前在VS Code上配置了C++编译运行的环境，详见[[I-VSCode-C++]]，但是这只针对单文件，虽然能够通过修改设置达到编译多文件的目的，但支持不是很好，因此想使用CMake来编译构建项目。\n[[z-cmake]]是生成makefile的工具，makefile是包含多条make命令的文件。\n安装 安装CMake 下载地址： https://cmake.org/download/\n选择合适版本下载。\n安装时选择加入系统环境变量，即Add CMake to the system PATH for the current user选项。\n安装VS Code拓展 CMake CMake Tools 正常安装完，打开一个cpp文件就能看到左下角状态栏中有CMake插件，如果没有，可以创建一个CMakeLists.txt文件激活，也可能是安装CMake时，添加到系统环境变量需要重启生效。\n建议在设置中关闭cmake.configureOnEdit，该设置是在CMakeLists.txt保存时自动配置CMake项目目录，但是我VS Code开了自动保存文件，导致编辑过程中自动配置。\n使用 创建一个简单的Hello World项目，在main.cpp中调用hello.h和hello.cpp定义的hello函数。 然后，我们来编写CMakeLists.txt文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #cmake verson，指定cmake版本 cmake_minimum_required(VERSION 3.23) #project name，指定项目的名称，一般和项目的文件夹名称对应 PROJECT(HelloWorld) #head file path, 头文件目录 INCLUDE_DIRECTORIES(include) #source directory，源文件目录，设置别名为DIR_SRC AUX_SOURCE_DIRECTORY(src DIR_SRC) #add executable file，添加要编译的可执行文件 ADD_EXECUTABLE(${PROJECT_NAME} ${DIR_SRC}) 然后点击VS Code下方状态栏中的Build或快捷键F7，会生成一个Build目录，该目录下会有Makefile文件。\n再点击下方三角形运行选项或快捷键Shift+F5，就能自动使用make编译文件并运行可执行文件。\n更多CMake语法可以查看[[z-cmake]]。\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-configuration/vscode-cmake/b-vscode-cmake/","summary":"前言 之前在VS Code上配置了C++编译运行的环境，详见[[I-VSCode-C++]]，但是这只针对单文件，虽然能够通过修改设置达到编译多","title":"VSCode CMake 环境配置与使用"},{"content":"正常来说不涉及AI的Python代码编写，只需要在 Python官网中下载安装Python，在VS Code中安装Python插件，就能愉快地开发了。考虑到深度学习环境的复杂度，我还是选择了Anaconda来管理。\n安装Anaconda 进入 Anaconda官网下载并安装，选择安装位置，并确定添加环境变量，耐心等待安装完成（可能比较久），应该没有什么困难。\n在命令行输入conda -V可以查看是否安装成功。\n如果提示无法识别指令的报错：\n1 2 conda: The term \u0026#39;conda\u0026#39; is not recognized as a name of a cmdlet, function, script file, or executable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. 是环境变量没有添加成功，需要手动将Anaconda安装目录下的Scripts目录加到环境变量PATH中。\nConda指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $conda list # 查看安装的组件 $conda update conda # 更新conda版本 # 创建一个叫做env的环境，使用3.9版本Python $conda create --name env python=3.9 $source activate env # 激活env环境(Linux 下) $activate env # 激活env环境(Windows 下) $source deactivate # 退出env环境(Linux 下) $deactivate # 退出env环境(Windows 下) $conda info -e # 列出环境 $conda env list # 列出环境 $conda remove --name env --all # 删除环境 使用PowerShell激活conda可能会发现没有反应，明明conda -V能看到版本号。参考：\nhttps://www.cnblogs.com/dereen/p/ps_conda_env.html https://blog.csdn.net/weixin_42613703/article/details/112169956\n执行conda init powershell，然后输入conda activate env来激活虚拟环境，注意这里conda以后不能省略。\n同理，如果是VS Code中终端激活没反应，也可能是关联的终端没有配置好。\n一般人到这里可能已经解决了，但我的问题是用了oh-my-posh美化终端时没有支持conda的样式，因此需要配置oh-my-posh，具体参见[[vscode_terminal#支持conda等环境]]。\n安装组件 使用conda search package_name可以查看组件的可以安装版本，使用conda install package_name进行安装。\n报错一 如果出现报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $conda install jupyter Collecting package metadata (current_repodata.json): failed CondaHTTPError: HTTP 000 CONNECTION FAILED for url \u0026lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json\u0026gt; Elapsed: - An HTTP error occurred when trying to retrieve this URL. HTTP errors are often intermittent, and a simple retry will get you on your way. If your current network has https://www.anaconda.com blocked, please file a support request with your network engineering team. \u0026#39;https://repo.anaconda.com/pkgs/main/win-64\u0026#39; 这里有几种解决方法：\n方法一：\n可能是网络问题导致，进行换源可以解决，以清华源为例\n1 2 3 4 5 6 7 8 9 $conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ $conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge $conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ # 设置搜索时显示通道地址 $conda config --set show_channel_urls yes #添加pytorch镜像 $conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 如果不行可以尝试使用http地址，也就是将s去掉，问题得到解决。\n方法二：\n关闭VPN，看别的博客中有许多人通过这一方法解决。 方法三:\n重装Anaconda，没办法的办法。\n报错二 安装到最后提示当前用户对Anaconda根目录没有写权限：\n1 2 EnvironmentNotWritableError: The current user does not have write permissions to the target environment. environment location: C:\\xxx\\anaconda 在根目录下安装的需要使用管理员权限运行，可以安装在别的虚拟环境下。\nVS Code 配置 安装Python插件，包含绝大多数功能：\n安装完之后我们创建一个.ipynb文件，自动激活插件。\n安装插件后，整体功能都一目了然。右上角可以选择我们创建好的虚拟环境来执行。\n输入代码print(\u0026quot;Hello World\u0026quot;)来测试是否能运行，其间提示需要安装ipykernel，安装完就可以正常运行了。\n至此，VS Code的Anaconda环境就算是搭完了。\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-configuration/vscode-python/b-vscode-python/","summary":"正常来说不涉及AI的Python代码编写，只需要在 Python官网中下载安装Python，在VS Code中安装Python插件，就能愉快地开","title":"VSCode Python 环境配置"},{"content":"Definition In computer science, a k-d tree (short for k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. (Wiki)\nReferences 知乎 k-d tree原理详解\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-kd-tree/","summary":"Definition In computer science, a k-d tree (short for k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. (Wiki) References 知乎 k-d tree原理详解","title":"k-d tree"},{"content":"CMake是一种跨平台编译工具，先编写CMakeLists.txt文件，然后使用cmake命令来生成对应的makefile文件，最后使用make命令编译源码。\nmake是比CMake低级的工具，执行makefile文件编译源码。\n编译指令：\n1 2 \u0026gt; cmake \u0026gt; make CMake语法：\nhttps://blog.csdn.net/hebbely/article/details/79169965\nVS Code联动： [[B-VSCode-CMake]]\n","permalink":"https://www.wangwangbu.com/posts/zettel/z-cmake/","summary":"CMake是一种跨平台编译工具，先编写CMakeLists.txt文件，然后使用cmake命令来生成对应的makefile文件，最后使用ma","title":"CMake"},{"content":" 题目链接： https://leetcode.cn/problems/can-i-win/\n思路 对于任一玩家，有两种情况：\n在当前可选集合中选择i，选择后满足大于等于desiredTotal，则该玩家赢。 不满足 1. 的情况下，需要判断是否存在这样的i，使得另一玩家无法获胜（通过相同函数判断）。如果存在，则该玩家获胜（只要这一情况下选i就行）；否则，该玩家无法获胜（不论选任意i，另一玩家都能获胜）。 搜索的状态可以包括 当前可选集合 和 当前还需累积和，由于存在重复搜索的情况，使用[[记忆化搜索]]可以节省时间。对于 当前可选集合 可以使用[[状态压缩]]的方式表示。\n注意到，两玩家每次必选一个整数，因此两人的搜索状态必然不同（可选集合的大小一奇一偶），无需额外区分。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int maxN; bool mem[1\u0026lt;\u0026lt;20] = {0}; // 题目给的最大可选整数为20个，状态最大是20个1，即2^20-1 // 2^20大小数组够用 bool dfs(unsigned int x, int tot) { if(mem[x]) return true; for(int i=0; i\u0026lt;maxN; i++) { if(((x\u0026gt;\u0026gt;i)\u0026amp;1)==0) { // 右移判断第i个整数是否可选 if(i+1\u0026gt;=tot) { // 第i整数对应值是i+1 mem[x] = true; return true; } if(!dfs(x|(1\u0026lt;\u0026lt;i),tot-(i+1))) { mem[x] = true; return true; } } } mem[x] = false; return false; } bool canIWin(int maxChoosableInteger, int desiredTotal) { maxN = maxChoosableInteger; // 判断给出整数总和小于所需累计和 if((1+maxN)*maxN/2\u0026lt;desiredTotal) { return false; } return dfs(0, desiredTotal); } }; ","permalink":"https://www.wangwangbu.com/posts/algo/leetcode/b-leetcode-465/","summary":"题目链接： https://leetcode.cn/problems/can-i-win/ 思路 对于任一玩家，有两种情况： 在当前可选集合中选择i，选择后满足大于等于desiredTotal，则该玩家赢。 不满足 1. 的情况下，","title":"Leetcode 456 我能赢么"},{"content":"创建指令 开发者可以为动作指定指令，通过两步操作：\n在package.json的contributes.commands定义命令。 在主要文件中使用vscode.commands.registerCommand注册命令。 关于 Command 更详细的介绍可以看这个 文档。\n使用vscode.commands.executeCommand指令可以主动调用指令，并且命令也可以有输入和输出参数。\n[[Command-URIs]]\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-extension/b-vscode-extension-2/","summary":"创建指令 开发者可以为动作指定指令，通过两步操作： 在package.json的contributes.commands定义命令。 在主要文件中使","title":"VSCode 插件开发 (2) 插件能力"},{"content":"介绍 VS Code 允许用户自定义代码段，通过自定义指令快速创建代码块。（ 官方文档）\n代码块分两种：\n全局代码块（在snippets目录下生成后缀名为.code-snippets的文件） 特定语言的代码块（生成对应语言.json文件） 可以在项目根目录的.vscode目录下添加后缀名为.code-snippets文件来定制当前工作环境下的代码块。\n使用 通过命令Preferences: Configure User Snippets管理和创建代码块。\n一个我[[Notes-in-VSCode]]元数据的例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;Metadata\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;markdown\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;/meta\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;创建这条笔记的元数据\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;---\u0026#34;, \u0026#34;date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\u0026#34;, \u0026#34;type: ${1|question,idea,life|}\u0026#34;, \u0026#34;tags: $2\u0026#34;, \u0026#34;---\u0026#34; ] } } 其中，Metadata是代码块的名字，包含以下字段：\nscope指定markdown文件使用 prefix设定调用的命令，也可以是for等形式，触发该代码块提示 description代码块说明 body代码块内容，当输入命令回车后会替换命令 在body中有$CURRENT_YEAR这种以$开头的变量，都是VS Code内置变量，具体可以查看官方文档\n还有$后面跟数字的是提示用户输入的占位符，调用命令后我们可以使用Tab键在这些地方切换输入。其中${1|blog,idea,life|}可以在输入的时候提供这几个选项。\n如果觉得写body十分麻烦，这里还有 snippet生成器网站。\n一些应用 生成博客的元信息 因为可以在新笔记的模板中设置上文元信息，/meta用来生成博客元信息，按需求改为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026#34;bMetadata\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;markdown\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;/bMeta\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;创建这条博客的元数据\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;---\u0026#34;, \u0026#34;title: $1\u0026#34;, \u0026#34;date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\u0026#34;, \u0026#34;lastmod: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\u0026#34;, \u0026#34;type: $2\u0026#34;, \u0026#34;series:\u0026#34;, \u0026#34;- \u0026#34;, \u0026#34;tags:\u0026#34;, \u0026#34;- $3\u0026#34;, \u0026#34;description: $4\u0026#34;, \u0026#34;draft: true\u0026#34;, \u0026#34;cover:\u0026#34;, \u0026#34; image: \u0026#34;, \u0026#34; caption: \u0026#34;, \u0026#34; alt: \u0026#34;, \u0026#34; relative: false\u0026#34;, \u0026#34;---\u0026#34;, ] } 不过发现可以使用[[b-foam-template]]自动生成，也就弃用了。\n还有其他语言的用法值得探究。\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-configuration/vscode-snippets/b-vscode-snippets/","summary":"介绍 VS Code 允许用户自定义代码段，通过自定义指令快速创建代码块。（ 官方文档） 代码块分两种： 全局代码块（在snippets目录下生成后缀名为.co","title":"VSCode Snippets 使用"},{"content":"前言 上来先放VS Code插件开发的 官方文档，说实话非常详细，没必要再看其他教程。\n该系列文章只是作为我学习的记录，也可在一些问题上给大家提供思路，有问题希望大家帮忙指正。\n开发环境 系统：Windows 10 编辑器: VS Code\n流程 安装Node.js 官网下载安装，设置安装到D盘，选择添加到Path。使用node -v和npm -v查看安装是否成功。\n问题：尽管修改了Node.js的默认安装文件夹，但该文件夹依然需要管理员权限操作，此问题可能造成npm install时提示没有mkdir操作权限的问题。 方法：需要右键属性-\u0026gt;安全-\u0026gt;编辑-\u0026gt;给Users所有权限。\n因为不想占用c盘，修改npm默认安装路径。先在安装文件夹下创建两个新文件夹node_cache和node_global。运行命令修改npm设置：\n1 2 npm config set prefix \u0026#34;D:/nodejs/node_global\u0026#34; npm config set cache\u0026#34;D:/nodejs/node_cache\u0026#34; 运行这两行代码没有提示，运行结束可以使用npm config ls查看路径是否修改成功。还需要将node_global文件夹路径添加到环境变量的path中。\n为了保持安装包的速度稳定，使用淘宝源，执行以下命令进行换源：\n1 npm config set registry http://registry.npm.taobao.org/ 使用yo创建项目 安装yo模块和generator-code模块来生成对应开发模板。\n1 npm install -g yo generator-code 安装成功后可以使用yo模块生成对应的项目结构。\n1 yo code 问题：VSCode中提示yo : 无法加载文件 D:\\nodejs\\node_global\\yo.ps1，因为在此系统上禁止运行脚本。 方法：参考 博客\n以管理员身份启动终端 终端执行get-ExecutionPolicy查看权限为Restricted，表示为禁止 在终端执行 set-ExecutionPolicy RemoteSigned，显示set-ExecutionPolicy : 对注册表项“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\PowerShell\\1\\ShellIds\\Microsoft.PowerShell”的访问被拒绝...根据提示使用Set-ExecutionPolicy Scope CurrentUser RemoteSigned修改 再次执行get-ExecutionPolicy，显示为RemoteSigned 第一个extension 按照官方文档的步骤，先创建一个HelloWorld项目进行学习。\n创建HelloWorld项目 使用yo code指令在当前目录创建，选择TypeScript语言，并输入extension名字为HelloWorld，是否使用git和webpack根据自己需求，我选的是No，包管理工具选择npm。\n最后选择在VSCode中打开项目，创建的是模板项目，之后也在这个模板上学习修改。\n运行HelloWorld项目 使用F5可以运行项目，弹出新的VSCode测试，使用快捷键ctrl+shift+p显示命令窗口，输入Hello World指令，能够看到右下角提示Hello World from HelloWorld!信息。\n运行后没有该命令：可能是没有以该项目为根目录打开，整个项目没有运行起来。\n该指令是模板写好的，我们可以通过修改代码体会代码结构。首先打开extension.js阅读，这里是具体实现。注释写的很清楚，仔细阅读也能懂个大概。\n通过修改extension.ts文件中vscode.window.showInformationMessage();里的字符串，从而修改提示信息内容。通过在测试窗口的命令行输入Reload Window指令重新加载查看效果。 可以看到该函数是在helloworld.helloWorld命令中执行，注释也说了这一命令是在package.json中定义，并且所有使用的命令名都要先定义好。通过查看package.json，能发现定义。每条命令包括command和title，前者是代码内使用，后者是用户使用，通过修改测试我们也能体会对照关系。 调试 在代码行前面点标记，能够添加断点，运行后会停在断电，同时在原窗口会显示变量信息。还是比较简易的。\n文件解析 拓展的模块主要由3部分组成：\nActivation Events: 触发插件的操作。 Contribution Points: 在package.json文件中的模块声明。 VS Code API: 模块在实现中的API。 最重要的设置文件就是package.json，其中main定义了入口文件。\n入口文件有两个函数：\nactivate: 当注册的 Activation Event 发生时执行。 deactivate: 在插件关闭前执行，大多时候用不到。 总结 这里是 Contribution Points 和 VS Code API，现在，相信你已经完全掌握了VS Code 插件开发，理清你的需求，然后愉快地coding吧！\n想要了解插件都能干什么，获得一些启发，可以和我一起继续学习[[b-vscode-extension-2]]。\n","permalink":"https://www.wangwangbu.com/posts/tech/vscode-extension/b-vscode-extension-1/","summary":"前言 上来先放VS Code插件开发的 官方文档，说实话非常详细，没必要再看其他教程。 该系列文章只是作为我学习的记录，也可在一些问题上给大家提供思","title":"VSCode 插件开发 (1) 安装和运行"},{"content":"往往不\n","permalink":"https://www.wangwangbu.com/about/","summary":"往往不","title":"🙋🏻‍♂️关于"},{"content":"准备从往往不实体中断开，请在下方选择想要转生的数据源。\n将安排专车🚘在 5s 内到达，请及时走到马路中央，感谢使用转生服务🙂\n","permalink":"https://www.wangwangbu.com/links/","summary":"准备从往往不实体中断开，请在下方选择想要转生的数据源。 将安排专车🚘在 5s 内到达，请及时走到马路中央，感谢使用转生服务🙂","title":"🚘转生"}]